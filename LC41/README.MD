# 41. 缺失的第一个正数
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

示例 1：

输入：nums = [1,2,0]
输出：3
示例 2：

输入：nums = [3,4,-1,1]
输出：2
示例 3：

输入：nums = [7,8,9,11,12]
输出：1
 
提示：

0 <= nums.length <= 300
-231 <= nums[i] <= 231 - 1

来自力扣 https://leetcode-cn.com/problems/first-missing-positive/

## 思路
本题难点不在解决而在算法效率，很容易想到下列不符合要求的算法：
1. 简单枚举法，但是显然时间复杂度为O(n^2)；对应Solution1.java
2. 先将数组放入哈希表，从1开始枚举，时空复杂度均为O(n)。对应Solution2.java

* 改进哈希表方法可以达到O(n)+O(1)的题目要求
分析算法②中的哈希表HashMap<key, value>，value实际类似一个bool类型，仅表示key元素出现过(1)，未出现(null)。
需要优化存储至O(1)就不能额外建立数据结构记录该“出现/未出现”情况，于是可以想到利用已有数组。
输入nums[]的索引可以被看作HashMap的key值，只需要对数据进行处理，表示该key位数字出现过即可。