863. 二叉树中所有距离为 K 的结点
给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。

返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。

示例 1：2021-07\LC863\sketch0.png

输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
输出：[7,4,1]
解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，
值分别为 7，4，以及 1

注意，输入的 "root" 和 "target" 实际上是树上的结点。
上面的输入仅仅是对这些对象进行了序列化描述。


提示：
给定的树是非空的。
树上的每个结点都具有唯一的值 0 <= node.val <= 500 。
目标结点 target 是树上的结点。
0 <= K <= 1000.

思路：
1. 暴力搜索：距离每个结点为k的结点即距离其子结点或父结点(k-1)的结点。
    distance(node, k) = distance(node.left, k-1) + distance(node.right, k-1) + distance(node.parent, k-1)
    这样理论上可以暴力递归解决，但是由于存在向上(父)和向下(子)两个方向，会出现死循环。
    其中父结点(node.parent)无法直接获得，可以通过遍历整棵树获得所有结点的父结点。

    递归：
    * 结束标志：
    1. 找到一个目标结点：distance(node, k)，即k=0，保存该结点，结束此递归分支。
    2. 不再存在父结点或子结点，不调用为空的对应结点。
    * 如何解决死循环？每个结点都具有唯一的值，以结点数值作为索引的数组记录是否已经过每一结点。
    * 注意判断结点为空的情况。

    * 复杂度：
    空间 O(N)
    时间 O(N)
    遍历获得父结点：O(N)
    递归查找：考虑总结点数，递归时最多遍历完所有结点一次，即O(N)。
    考虑以k迭代的调用次数，距离为k调用1次，距离为(k-1)调用至多3次，... 距离为0调用至多3^k次。总最多(3^(k+1)-1)/2次，即O(3^(k+1))。
    因此时间复杂度为O(N)。
    
    * 总结：由于每个结点总是只会经过一次，搜索中不存在重复，直接递归可以达到优秀的效率。



2. 建图，迭代生成全部结点与target的距离(Dijkstra算法)
   参考：https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-x6hak/ 宫水三叶 - 建图+迭代加深法
